[TOC]
 
 
 
# Windows核心编程课程概览
 
一个操作系统下的学习:
 
1. 进程和线程
2. 文件/目录系统
3. 内存管理
4. 网络
5. 可执行文件格式
 
 
 
 
 
# PE文件格式
 
> 讲的是一个exe/dll/sys等可执行文件的文件存储格式.
>
> 主要的应用方向 : 脱壳和加壳 , 病毒分析.
 
- 熟悉PE文件的一些常用的概念
- 了解每个PE文件的表.
 
## 文件格式
 
一个文件由两部个部分组成:
 
  1. 头部
       1. dos头
            1. `e_magic` 保存PE文件的标识,值是`0x5A4D`
            2. `e_lfanew` : 保存着NT头的文件偏移.
            3. DOS结束之后还有一段字节数不固定的DOS stub部分,这个部分一般保存一段代码.
 
       2. NT头
            1. NT的位置记录在dos头中的``e_lfanew` `
 
            2. 文件头
                 1. 可执行文件所能运行的CPU平台
                 2. 区段的总个数
                 3. 扩展头的大小
                 4. 文件属性
 
            3. 扩展头
 
              1. magic : 保存了PE文件的类型(32位/64位)
 
              2. AddressOfEntryPointer : 程序入口点(俗称OEP),保存的是一个RVA.
 
              3. ImageBase : 预定义的加载基址 , 一般exe的默认的加载基址是:0x400000,dll的默认加载基址是0x10000000 , 当系统要运行一个exe一般都会按照这个数作为一个内存地址来将pe文件加载到内存中.
 
              4. SizeofImage : 映像大小(PE文件加载到内存之后的大小)
 
              5. SizeOfHeaders : 整个头部的字节数(dos+dos stub + 文件头 + 扩展头 + 区段头表)
 
              6. DataDirection: 数据目录表数组,保存着各个表的首地址和大小.
                数组中的每个元素都保存着固定的表的rva和size, 当pe文件没有其中一张表的时候,只会把这个元素置0,而不会从数组中删除这个元素. 下面是数组元素下标对应的表:
 
                ```c
                #define IMAGE_DIRECTORY_ENTRY_EXPORT        0x0     //[0x78] (1)
                #define IMAGE_DIRECTORY_ENTRY_IMPORT        0x1     //[0x80] (2)
                #define IMAGE_DIRECTORY_ENTRY_RESOURCE    0x2     //[0x88] (3)
                #define IMAGE_DIRECTORY_ENTRY_EXCEPTION    0x3     //[0x90] (4)
                #define IMAGE_DIRECTORY_ENTRY_SECURITY    0x4     //[0x98] (5)
                #define IMAGE_DIRECTORY_ENTRY_BASERELOC    0x5     //[0xA0] (6)
                #define IMAGE_DIRECTORY_ENTRY_DEBUG        0x6     //[0xA8] (7)
                #define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    0x7     //[0xB0] (8)
                #define IMAGE_DIRECTORY_ENTRY_GLOBALPTR    0x8     //[0xB8] (9)
                #define IMAGE_DIRECTORY_ENTRY_TLS        0x9     //[0xC0] (10)
                #define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    0xA     //[0xC8] (11)
                #define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT    0xB     //[0xD0] (12)
                #define IMAGE_DIRECTORY_ENTRY_IAT        0xC     //[0xD8] (13)
                #define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT    0xD     //[0xE0] (14)
                #define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 0xE  //[0xE8] (15)
                ```
 
 
 
## 解析dos头和nt头
 
            ## 代码解析DOS和NT头
 
            ```c++
            // PE001.cpp : 定义控制台应用程序的入口点。
            //
 
            #include "stdafx.h"
            #include <windows.h>
 
            int main()
            {
                // 四大头对应的结构体
                IMAGE_DOS_HEADER;
                IMAGE_NT_HEADERS;
                IMAGE_FILE_HEADER;
                IMAGE_OPTIONAL_HEADER;
                // 解析一个pe文件的头部
                // 1. 将文件的内容读取到内存中.
                HANDLE hFile = CreateFile(L"D:\\RDll.exe",
                    GENERIC_WRITE|GENERIC_READ,/*文件的读写模式*/
                    FILE_SHARE_READ,/*和其它程序共享读*/
                    NULL,
                    OPEN_EXISTING/*文件存在才打开*/,
                    FILE_ATTRIBUTE_NORMAL,/*一个普通文件*/
                    NULL);
                if (hFile == (HANDLE)-1) {
                    printf("文件不存在\n");
                    return 0;
                }
                DWORD size = GetFileSize(hFile, NULL);
                LPBYTE pBuff = new BYTE[size];
                DWORD dwRead = 0;
                ReadFile(hFile, pBuff, size, &dwRead, 0);
 
                // 2. 使用对应的结构体解析内存中的数据
                IMAGE_DOS_HEADER* pDos = NULL;
                pDos = (IMAGE_DOS_HEADER*)pBuff;
                if (pDos->e_magic != IMAGE_DOS_SIGNATURE) {
                    printf("不是有效的PE格式\n");
                    return 0;
                }
                // 2.1 找到NT头
                IMAGE_NT_HEADERS* pNt = NULL;
                pNt = (IMAGE_NT_HEADERS*)(pDos->e_lfanew + pBuff);
                if (pNt->Signature != IMAGE_NT_SIGNATURE) {
                    printf("不是有效的PE格式\n");
                    return 0;
                }
 
                //DWORD offset = FIELD_OFFSET(IMAGE_DOS_HEADER, e_lfanew);
                // 使用汇编来解析:
                _asm
                {
                    ;// 得到dos头的magic的值, 然后判断是否等于0x5a4d
                    push eax; // 保存寄存器
                    mov eax, pBuff; // 将指针的值保存到eax
                    mov ax, word ptr [eax+0];// 取pBuff第0个字节的内容,实际就是e_magic的值
                    cmp ax, 0x5a4d;
                    pop eax; // 恢复寄存器
                    jne _EXIT;
                    ; 输出提示;
                }
 
                _asm
                {
                    ;// 得到nt头的首地址 : dos.e_lfanew + 缓冲区首地址
                    push eax;
                    mov eax, pBuff; // 得到文件缓冲区的首地址(dos头的首地址)
                    mov eax, dword ptr[eax + 0x3c];//得到e_lfanew的值
                    add eax, pBuff; // 加上文件缓冲区的首地址,得到NT头的首地址
                    cmp dword ptr[eax], 0x00004550;//将NT头的Signature字段的值比较
                    pop eax;
                    jne _EXIT;
                }
 
            _EXIT:
                CloseHandle(hFile);
                delete[] pBuff;
                return 0;
            }
            ```
 
 
 
---
 
 
 
3. 区段头表
 
    1. 区段头的位置 : Nt头的首地址 + 整个NT头的大小
    2. 区段头的个数 : Nt头中的文件头内的:`NumbeOfSection`;
    3. 字段的含义:
        1. name  : 区段的名字 , 大小是固定的8字节. 一般以`.`开头的区段名表示是系统的区段头. 系统会预定义一些区段的名字:
            1. .text  : 代码段
            2. .data : 数据段
            3. .rdata : 制度数据段
            4. .reloc : 重定位数据段
            5. .rsrc : 资源数据段
         2. misc.VirtualSize : (联合体)保存区段数据对齐之前的实际字节数
         3. SizeofRawData : 区段数据经过文件对齐粒度对齐后的大小.
         4. VirtualAddress :  内存偏移(RVA) , 记录的是文件加载内存中之后, 区段数据在内存中的RVA.
         5. PointerToRawData : 文件偏移(FOA),记录中文件没有被加载时, 区段数据的文件偏移.
         6. CharXXXX : 区段属性 , 记录了区段在内存中的属性(是否包含了代码,数据,未初始化数据, 以及区段数据在内存中是否具有读,写,执行的权限)
 
 
 
##遍历区段头
 
```c++
 
             // 遍历所有的区段头表
             // 1. 找到区段头数组的首地址
             // 首地址 = Nt头的首地址 + Nt头的总字节数
             IMAGE_SECTION_HEADER* pScnHdr = NULL;
             //pScnHdr = (IMAGE_SECTION_HEADER*)
             //((LPBYTE)pNt
             //    + sizeof(DWORD)
             //    + sizeof(IMAGE_FILE_HEADER)
             //    + pNt->FileHeader.SizeOfOptionalHeader);
 
             // 使用宏来找到区段头数组首地址
             pScnHdr = IMAGE_FIRST_SECTION(pNt);
 
             // 2. 得到区段头的个数
             DWORD scnHdrCount = pNt->FileHeader.NumberOfSections;
             for (DWORD i = 0; i < scnHdrCount; i++)
             {
                 printf("[%s]\n", pScnHdr[i].Name);
                 printf("\t实际字节数: %08X\n", pScnHdr[i].Misc.VirtualSize);
                 printf("\t对齐后节数: %08X\n", pScnHdr[i].SizeOfRawData);
                 printf("\t文件偏移: %08X\n", pScnHdr[i].PointerToRawData);
                 printf("\t内存偏移: %08X\n", pScnHdr[i].VirtualAddress);
             }
```
 
# rva转文件偏移
 
```c++
 
// 虚拟内存偏移 转 文件偏移
DWORD rva2foa(IMAGE_NT_HEADERS* pNt , DWORD dwRva )
{
    // 1. 遍历区段头表
    // 2. 找到rva所属的区段
    // 2.1 判断rva是否大于区段的开始地址 并且 小于区段的结束地址
    // 3. 得到区段的段首rva(虚拟内存偏移)
    // 3.1 得到区段的段首的foa(文件偏移)
    // 4. 将rva - 段首rva => 差值
    // 5. 差值 + 段首foa => rva对应的foa
    IMAGE_SECTION_HEADER* pScnHdr = (IMAGE_SECTION_HEADER*)
        IMAGE_FIRST_SECTION(pNt);
    for (DWORD i = 0; i < pNt->FileHeader.NumberOfSections; ++i) {
        if (dwRva >= pScnHdr[i].VirtualAddress
            && dwRva <= pScnHdr[i].VirtualAddress + pScnHdr[i].SizeOfRawData)
        {
            return dwRva - pScnHdr[i].VirtualAddress + pScnHdr[i].PointerToRawData;
        }
    }
 
    // 使用汇编实现上述逻辑:
 
    _asm {
        push eax; // 保存寄存器
        push ebx;// 保存寄存器
        push esi;// 保存寄存器
        push edx;// 保存寄存器
 
        mov esi, pNt; // esi 保存nt的首地址
        mov esi,dword ptr [esi + 0x14]; //esi+14:Nt.FIleHeader.SizeofOptionHeader;
 
        mov ebx, 0x18; // Nt头,sigXX + sizeof(FILE_HEADER)的字节数
        add ebx, esi;// ebx 得到整个Nt头的大小
 
        mov eax, pNt;// 得到nt头的首地址
        add eax, ebx; // 加上nt头的大小, eax :区段头的首地址
 
        ;// 建立循环遍历区段头
        ;
        ; // 获取区段的个数
        xor ebx,ebx
        mov bx, word ptr [esi + 6]; // esi+6 : Nt.FIleHeader.NumberOfSection
 
        mov esi, dwRva; // 将待转换的rva保存到寄存器
    _FOR:
        ; //判断rva是否大于区段的开始地址
        cmp esi, [eax + 0x0C]; // eax + 0x0C : 区段.VirtualAddress
        jl _CONTINUE;
        mov edx, [eax + 0x10];// eax + 0x10 : 区段.SizeOfRawData
        ;// 获取到区段的结束的偏移
        add edx, [eax + 0x0C];// eax + 0x0C : 区段.VirtualAddress
        cmp esi, edx;
        jg _CONTINUE;
 
        sub esi , [eax + 0x0C]; // eax + 0x0C : 区段.VirtualAddress
        add esi, [eax + 0x14];//eax+0x14 : 区段.PointerToRawData
        mov eax, esi; // 保存返回值到eax中.
        jmp _EXIT;
 
_CONTINUE:
        dec ebx
        cmp ebx, 0;
        jnz _FOR;
 
_EXIT:
        pop edx;// 恢复寄存器
        pop esi;// 恢复寄存器
        pop ebx;// 恢复寄存器
        pop eax;// 恢复寄存器
    }
 
    return -1;
}
 
```
 
 
 
 
 
  2. 文件主体(区段数据)