---
layout: blog
book: true
title:  "Windows驱动开发(第三天)"
background-image: http://ot1cc1u9t.bkt.clouddn.com/17-7-17/89166189.jpg
date:   2018-09-19 7:59:16
category: 安全
tags:
- 驱动开发 
---


# 0x00 串口过滤概念
在Windows系统上与安全软件相关的驱动开发过程，```过滤(filter)```是极其重要的一个概念.过滤是在不影响上层和下层接口的情况下，在Windows系统内核中加入新的层，从而不需要修改上层的软件或者下层的真实驱动程序，就加入了新的功能


# 0x01 设备绑定的内核API之一


进行过滤的最主要的方法是对一个设备对象(Device Object)进行绑定。

一个真实的设备对应一个设备对象..(虽然实际对应关系可能复杂的多)。但是通过代码可以生成一个虚拟的设备对象，并```绑定(Attach)```在一个真实的设备上。一旦绑定，则本来操作系统发送给真实设备的请求，就回首先发送到这个虚拟设备。

IoAttachDevice函数原型:
```c++
NTSTATUS IoAttachDevice(
  _In_   PDEVICE_OBJECT SourceDevice,
  _In_   PUNICODE_STRING TargetDevice,
  _Out_  PDEVICE_OBJECT *AttachedDevice
);

SourceDevice是调用者生成的用来过滤的虚拟设备。
TargetDevice是要被绑定的目标设备...这里TargetDevice不是一个PDEVICE_OBJECT，而是一个字符串。实际上这个字符串是要被绑定的设备的名字。
AttachedDevice是一个用来返回的指针的指针，绑定成功后，被绑定的设备指针被返回到这个地址。
```

Windows中许多设备对象是有名字的，但不是所有的设备对象都有名字，必须有名字的设备才可以用这个API来进行绑定。


假设这个函数绑定一个名字所对应的设备，那么如果这个设备已经被其他的设备绑定过了，会怎么样？
如果一个设备被其他设备绑定，它们在一起的一组设备，被称为设备栈，实际上IoAttachDevice总是会绑定设备栈上最顶层的那个设备。


## 0x01.1 举个栗子(绑定串口1)

```c++
UNICODE_STRING com_name = RTL_CONSTANT_STRING(L"\\Device\\Serial0");
NTSTATUS status = IoAttachDevice(
	com_filter_device,//生成的过滤设备
	&com_name,//串口的设备命
	&attached_device//被绑定的设备指针返回到这里
	);		
```

当然现在肯定是绑定失败的，因为没有过滤设备的代码...

# 0x02 设备绑定的内核API之二

前面已经提到了并不是所有的设备都有设备名，所以依靠IoAttachDevice无法绑定没有名字的设备。
另外还有两个API：一个是```IoAttachDeviceToDeviceStack```,另外一个是```IoAttachDeviceToDeviceStackSafe```
这两个函数的功能是一样的，都是根据设备对象的指针(不是名字)进行绑定...区别是```IoAttachDeviceToDeviceStackSafe```更加安全
```IoAttachDeviceToDeviceStackSafe:只在Windows 2000 Sp4和Windows Xp以上的系统中才有```
```IoAttachDeviceToDeviceStack可以兼容较低版本的Windows```

IoAttachDeviceToDeviceStackSafe函数原型:

```c++
NTSTATUS IoAttachDeviceToDeviceStackSafe(
  _In_   PDEVICE_OBJECT SourceDevice,
  _In_   PDEVICE_OBJECT TargetDevice,
  _Out_  PDEVICE_OBJECT *AttachedToDeviceObject
);
和IoAttachDevice类似，只是```TargetDevice```换成了指针。另外```AttachedToDeviceObject```同样也是返回最终被绑定的设备，实际上就是绑定之前设备栈上最顶端的那个设备..
```

IoAttachDeviceToDeviceStack函数原型:
```c++
PDEVICE_OBJECT IoAttachDeviceToDeviceStack(
  _In_  PDEVICE_OBJECT SourceDevice,
  _In_  PDEVICE_OBJECT TargetDevice
);
这个函数缺少了```AttachedToDeviceObject```(实际上放在了返回值里),其他的与```IoAttachDeviceToDeviceStackSafe```函数相同
这个函数返回了最终被绑定的设备指针，这也导致了它不能返回一个明确的错误码，但是如果为NULL，则表示绑定失败了
```

# 0x03 生成过滤设备并绑定

在绑定一个设备之前，先要知道如何生成一个用于过滤的过滤设备。
函数```IoCreateDevice```被用于生成设备:

```c++
NTSTATUS IoCreateDevice(
  _In_      PDRIVER_OBJECT DriverObject,
  _In_      ULONG DeviceExtensionSize,
  _In_opt_  PUNICODE_STRING DeviceName,
  _In_      DEVICE_TYPE DeviceType,
  _In_      ULONG DeviceCharacteristics,
  _In_      BOOLEAN Exclusive,
  _Out_     PDEVICE_OBJECT *DeviceObject
);
```

emmmm...看上去好复杂啊.但是目前使用的时候，还不需要了解太多。

```DriverObject```是本驱动的驱动对象。这个指针是系统提供，从DriverEntry中传入

```DeviceExtensionSize```是设备扩展，暂时可以先传0

```DeviceName```是设备名称。一个规则是:过滤设备一般不需要名称，所以传入NULL就好了..

```DeviceType```是设备类型，保持和被绑定的设备类型一致即可。

```DeviceCharacteristics```是设备特征，在生成设备对象时，习惯填0，然后看是否排斥，选择FALSE.

这里有一个关键点:在绑定一个设备之前，应该把这个设备对象的多个子域设置成和要保定的目标对象一致，包括标志和特征。

示例函数(生成一个设备，然后绑定到另一个设备上):
```c++
#include <ntddk.h>
NTSTATUS ccpAttachDevice(PDRIVER_OBJECT driver, PDEVICE_OBJECT oldobj, PDEVICE_OBJECT *fltobj, PDEVICE_OBJECT *next)
{
	NTSTATUS status;
	PDEVICE_OBJECT topdev = NULL;
	//生成设备，然后绑定
	status = IoCreateDevice(driver, 0, NULL, oldobj->DeviceType, 0, FALSE, fltobj);
	if (status != STATUS_SUCCESS)
	{
		return status;
	}
	//拷贝重要标志位
	if (oldobj->Flags & DO_BUFFERED_IO)
	{
		(*fltobj)->Flags |= DO_BUFFERED_IO;
	}
	if (oldobj->Flags&DO_DIRECT_IO)
	{
		(*fltobj)->Flags |= DO_DIRECT_IO;
	}
	if (oldobj->Characteristics&FILE_DEVICE_SECURE_OPEN)
	{
		(*fltobj)->Characteristics |= FILE_DEVICE_SECURE_OPEN;
	}
	(*fltobj)->Flags |= DO_POWER_PAGABLE;
	//将一个设备绑定到另一个设备上
	topdev = IoAttachDeviceToDeviceStack(*fltobj, oldobj);
	if (topdev == NULL)
	{
		//如果绑定失败了，销毁设备，返回错误
		IoDeleteDevice(*fltobj);
		*fltobj = NULL;
		status = STATUS_UNSUCCESSFUL;
		return status;
	}
	*next = topdev;
	//设置这个设备已经启动
	(*fltobj)->Flags = (*fltobj)->Flags&~DO_DEVICE_INITIALIZING;
	return STATUS_SUCCESS;
}
```



## 0x03.1 从名字获得设备对象

在知道一个设备名字的情况下,使用```IoGetDeviceObjectPointer```可以获得这个设备对象的指针，这个函数的原型如下:
```c++
NTSTATUS IoGetDeviceObjectPointer(
  _In_   PUNICODE_STRING ObjectName,
  _In_   ACCESS_MASK DesiredAccess,
  _Out_  PFILE_OBJECT *FileObject,
  _Out_  PDEVICE_OBJECT *DeviceObject
);
ObjectName就是设备名
DesiredAccess是期望所得到的权限，直接FILE_ALL_ACCESS。
FileObject是一个返回参数，获得这个设备对象的同时会得到一个文件对象(File Object)..
```
要得到的设备对象就返回在参数```DeviceObject```中了

## 0x03.2 从名字获得设备对象的示例
```c++
#include <ntddk.h>
#define NTSTRSAFE_LTB
#include <ntstrsafe.h>

//打开一个端口设备
PDEVICE_OBJECT ccpOpenCom(ULONG id, NTSTATUS *status)
{
	//外面输入的是串口ID，这里会改写成字符串的形式
	UNICODE_STRING name_str;
	static WCHAR name[32] = {0};
	PFILE_OBJECT fileobj = NULL;
	PDEVICE_OBJECT devobj = NULL;

	//根据id转换成串口的名字
	memset(name, 0, sizeof(WCHAR)*32);
	RtlStringCchPrintfW(name, 32, L"\\Device\\Serial%d", id);
	RtlInitUnicodeString(&name_str, name);

	//打开设备对象
	*status = IoGetDeviceObjectPointer(&name_str, FILE_ALL_ACCESS, &fileobj, &devobj);
	//如果打开了 一定要把文件对象接触引用
	if (*status == STATUS_SUCCESS)
	{
		ObDereferenceObject(fileobj);
	}
	//返回设备对象
	return devobj;
}
```

## 0x03.3 绑定所有串口

计算机到底有多少个串口呢？？？我也不知道~.~ ，除了依次去打开串口0、1、2、3···，目前还不知道如果串口2不存在，是否说明串口3、4···肯定不存在？
这是没有依据的，所以只好全部测试一次。不过有一个好处是，串口是焊死在计算机上的，很少能见到能"即插即用"的串口(但是有一种用USB口来虚拟串口的设备，不知道会不会产生动态生成串口的效果，在这里先忽略这一点)
那么绑定所有串口，就只需要做一次就可以了，不用去动态的追踪串口的诞生与消亡。

下面是一个简单的函数，实现了绑定本机上所有串口的功能。这个函数用到了前面提供的ccpOpenCom和ccpAttachDevice这两个函数

```c++
//计算机上最多只有32个串口[这是我意淫的...]
#define  CCP_MAX_COM_ID 32
//保存所有过滤设备的指针
static PDEVICE_OBJECT s_fltobj[CCP_MAX_COM_ID] = {0};
//保存所有真实设备的指针
static PDEVICE_OBJECT s_nextobj[CCP_MAX_COM_ID] = { 0 };

//这个函数绑定所有的串口
void ccoAttachAllComs(PDRIVER_OBJECT driver)
{
	ULONG i;
	PDEVICE_OBJECT com_ob;
	NTSTATUS status;
	for (i = 0; i < CCP_MAX_COM_ID;i++)
	{
		//获得OBJECT引用
		com_ob = ccpOpenCom(i,&status);
		if (com_ob == NULL)
		{
			continue;
		}
		//在这里绑定，并不管绑定成功不成功
		ccpAttachDevice(driver,com_ob,&s_fltobj[i],&s_nextobj[i]);
	}
}
```
没有必要关心绑定是否成功，就算是失败了，看一下```s_fltobj```就好了...
这个数组中不为NULL的成员表示已经绑定了，为NULL的成员则是没有绑定或者绑定失败的...
这个函数需要一个DRIVER_OBJECT的指针，这是本驱动的驱动对象，是系统在```DriverEntry```中传入的。