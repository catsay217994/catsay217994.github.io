---
layout: blog
book: true
title:  "APC(一)"
background-image: http://ot1cc1u9t.bkt.clouddn.com/17-7-17/89166189.jpg
date:   2018-12-23 14:53:16
category: 安全
tags:
- APC
---


线程是不能被“杀掉”、“挂起”、“恢复”的，线程在执行的时候自己占据着CPU,别人怎么可能控制它呢？

 举个极端的例子：如果不调用API,屏蔽中断,并保证代码不出现异常，线程将永久占用CPU，何谈控制呢?所以说线程如果想“死”，一定是自己执行代码把自己杀死，不存在“他杀”这种情况！

 那如果想改变一个线程的行为该怎么办呢?

 可以给他提供一个函数，让它自己去调用，这个函数就是APC
(Asyncroneus Procedure Call)，即异步过程调用。

WinDbg查看当前线程结构体: dt _KTHREAD.
+0x034 ApcState         : _KAPC_STATE
子结构体的结构:dt _KAPC_STATE
```c++

nt!_KAPC_STATE
   +0x000 ApcListHead	//2个APC队列 用户APC和内核APC函数地址小于8就是用户空间 大于8就是内核 16字节[我们提供的APC函数就挂在这里] 一个双向链表挂用户 一个挂内核
   +0x010 Process		//线程所属或者所挂靠的进程
   +0x014 KernelApcInProgress	//内核APC是否正在执行
   +0x015 KernelApcPending	//是否有正在等待执行的内核APC
   +0x016 UserApcPending	//是否有正在等待执行的用户APC
```

Process挂靠的应该和dt _ETHREAD中的ThreadsProcess保持一致

```c++
kd>dt _ETHREAD

+0x220 ThreadsProcess   : Ptr32 _EPROCESS

```



APC的结构：
```c++
kd> dt _KAPC
nt!_KAPC
   +0x000 Type
   +0x002 Size
   +0x004 Spare0                               
   +0x008 Thread                                 
   +0x00c ApcListEntry
   +0x014 KernelRoutine
   +0x018 RundownRoutine
   +0x01c NormalRoutine//指向的是你真正希望线程执行的那个函数  找到你提供的APC函数，并不完全等于APC函数的地址
   +0x020 NormalContext
   +0x024 SystemArgument1
   +0x028 SystemArgument2
   +0x02c ApcStateIndex
   +0x02d ApcMode
   +0x02e Inserted
```

KiServiceExit函数:这个函数是系统调用、异常或中断返回用户空间的必经之路。
KiDeliverApc函数：负责执行APC函数
